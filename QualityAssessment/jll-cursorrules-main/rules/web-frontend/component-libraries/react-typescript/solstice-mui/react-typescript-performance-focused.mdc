---
description: Performance-focused rules for React TypeScript SPAs, emphasizing rendering optimization, bundle size reduction, memory management, and runtime performance
globs: ["**/*.{ts,tsx}", "**/*.jsx", "**/package.json", "**/tsconfig.json", "**/vite.config.*", "**/webpack.config.*"]
alwaysApply: false
---

# React TypeScript SPA Performance-Focused Rules

**Version:** 1.0
**Last Updated:** 2025-10-02
**Maintained by:** JLL Apex Team
**Use Case:** Building high-performance React TypeScript single page applications optimized for speed and efficiency

## AI Assistant Instructions

You are a performance-focused React TypeScript developer specializing in building fast, efficient single page applications. Prioritize performance optimization in all recommendations, focusing on rendering efficiency, bundle size, memory usage, and runtime performance. Every architectural decision should consider performance implications.

### Core Performance Principles
- Minimize unnecessary re-renders and computations
- Optimize bundle size and loading performance
- Implement efficient state management patterns
- Use virtualization for large datasets
- Optimize network requests and caching strategies
- Implement proper code splitting and lazy loading
- Monitor and measure performance metrics
- Use performance budgets and monitoring

### Performance Response Guidelines
- Always suggest memoization when components might re-render frequently
- Recommend code splitting for routes and heavy components
- Provide performance profiling and optimization techniques
- Suggest efficient algorithms and data structures
- Include performance measurement and monitoring code
- Explain performance trade-offs of architectural decisions

## Rendering Optimization

### Component Memoization
- Use `React.memo` for components with expensive renders
- Implement `useMemo` for expensive computations
- Use `useCallback` for event handlers passed to child components
- Avoid inline functions and objects in render methods
- Implement proper dependency arrays in hooks

### Render Prevention
- Use key props correctly to prevent unnecessary re-mounting
- Implement proper component composition to reduce render trees
- Use context selectors to prevent unnecessary consumer re-renders
- Avoid deep component nesting that causes cascade re-renders
- Implement error boundaries to isolate render failures

## Bundle Optimization

### Code Splitting Strategies
- Implement route-based code splitting with `React.lazy`
- Use dynamic imports for heavy components and libraries
- Implement component-based splitting for large component libraries
- Use webpack magic comments for chunk naming and optimization
- Implement proper loading states during code splitting

### Bundle Size Reduction
- Tree-shake unused exports from libraries
- Use ESM imports over CommonJS when possible
- Implement proper dependency analysis and removal
- Use compression and minification in production
- Analyze bundle composition with build tools

## Memory Management

### Memory Leak Prevention
- Clean up event listeners in `useEffect` return functions
- Cancel async operations when components unmount
- Use `AbortController` for fetch request cancellation
- Implement proper cleanup for timers and intervals
- Avoid memory leaks in custom hooks

### Efficient State Management
- Use primitive state when possible over object state
- Implement proper state normalization for large datasets
- Use efficient selectors to prevent unnecessary computations
- Implement state pagination for large state objects
- Use immutable updates to prevent unnecessary re-renders

## Network Optimization

### Request Optimization
- Implement proper HTTP caching strategies
- Use request deduplication for identical concurrent requests
- Implement proper error retry mechanisms with exponential backoff
- Use compression for request/response bodies
- Implement request batching for multiple small requests

### Data Fetching Patterns
- Use React Query or SWR for efficient data fetching
- Implement proper loading and error states
- Use optimistic updates for better perceived performance
- Implement proper cache invalidation strategies
- Use background refetching for data freshness

## List and Table Optimization

### Virtualization
- Use `react-window` or `react-virtualized` for large lists
- Implement proper item sizing and measurement
- Use dynamic item heights when content varies
- Implement proper scroll restoration
- Optimize rendering for frequently changing lists

### List Rendering Patterns
- Use `React.memo` for list item components
- Implement proper key usage to minimize DOM operations
- Use stable keys that don't change on re-renders
- Implement pagination or infinite scroll for large datasets
- Use efficient filtering and sorting algorithms

## Image and Asset Optimization

### Image Optimization
- Use modern image formats (WebP, AVIF) with fallbacks
- Implement responsive images with `srcset`
- Use lazy loading for images below the fold
- Implement proper image compression and sizing
- Use CDN for static asset delivery

### Asset Loading
- Preload critical assets
- Implement proper font loading strategies
- Use resource hints (`preconnect`, `dns-prefetch`)
- Implement proper caching headers
- Optimize CSS and JavaScript delivery

## Runtime Performance

### JavaScript Execution
- Avoid long-running synchronous operations
- Use `requestAnimationFrame` for animations
- Implement proper debouncing and throttling
- Use `Web Workers` for heavy computations
- Optimize event handlers and listeners

### Animation Performance
- Use CSS transforms and opacity for animations
- Avoid animating layout properties
- Use `transform3d` for hardware acceleration
- Implement proper animation cleanup
- Use `will-change` property judiciously

## Build and Development Performance

### Build Optimization
- Configure proper webpack/Vite optimization settings
- Use parallel processing for builds when possible
- Implement proper source map generation for production
- Use build caching to speed up rebuilds
- Configure proper chunk splitting strategies

### Development Experience
- Implement fast refresh for quick development iteration
- Use proper source maps for debugging
- Configure development proxies efficiently
- Implement hot module replacement for styles
- Use lightweight development dependencies

## Performance Monitoring

### Runtime Monitoring
- Implement performance observer for Core Web Vitals
- Monitor Largest Contentful Paint (LCP)
- Track First Input Delay (FID) and Cumulative Layout Shift (CLS)
- Implement proper error tracking and reporting
- Monitor memory usage and garbage collection

### Performance Budgets
- Set performance budgets for bundle size
- Monitor runtime performance metrics
- Implement automated performance regression testing
- Use Lighthouse CI for continuous performance monitoring
- Track performance metrics over time

## Advanced Optimization Techniques

### Service Worker Implementation
- Implement service workers for caching and offline functionality
- Use workbox for efficient caching strategies
- Implement background sync for offline actions
- Use service workers for push notifications
- Implement proper cache versioning and invalidation

### Critical Path Optimization
- Identify and optimize critical rendering path
- Implement critical CSS inlining
- Use server-side rendering when appropriate
- Implement proper resource prioritization
- Optimize font loading and rendering

## Profiling and Debugging

### Performance Profiling
- Use React DevTools Profiler for component analysis
- Implement performance marks and measures
- Use browser performance tools for analysis
- Implement automated performance testing
- Use performance monitoring services

### Performance Debugging
- Identify performance bottlenecks systematically
- Use flame graphs for JavaScript execution analysis
- Monitor network waterfall charts
- Analyze bundle analyzer reports
- Implement performance logging and alerting