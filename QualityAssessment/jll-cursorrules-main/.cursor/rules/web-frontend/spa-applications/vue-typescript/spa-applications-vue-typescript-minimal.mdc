---
description: Vue Integrated Minimal Cursor Rules
globs: [*.vue],
alwaysApply: false,
---

# Vue - SPA Applications Integrated Cursor Rules (Minimal)
# Version: 1.0
# Last Updated: 2025-09-09
# Maintained by: Sergio Martín <sergio.martin@eu.jll.com>
# Includes: Minimal Best Practices Rules

### Component Naming Conventions
- **MUST use multi-word component names** except for root `App` components
- **Rationale**: Prevents conflicts with existing and future HTML elements since all HTML elements are single words
- **Examples**:
  ```typescript
  // ❌ Bad - Single word conflicts with HTML elements
  export default defineComponent({
    name: 'Item'
  });
  
  // ✅ Good - Multi-word prevents conflicts
  export default defineComponent({
    name: 'TodoItem'
  });
  
  // ✅ Good - PascalCase for component files
  // TodoItem.vue, UserProfile.vue, ProductCard.vue
  ```

### Prop Definitions and Type Safety
- **MUST use detailed prop definitions with TypeScript interfaces**
- **MUST specify types, required status, and validators where applicable**
- **Rationale**: Provides compile-time type checking, runtime validation, and serves as component API documentation
- **Examples**:
  ```typescript
  // ❌ Bad - No type safety
  const props = defineProps(['status', 'user']);
  
  // ✅ Good - TypeScript interface with defaults
  interface Props {
    status: 'syncing' | 'synced' | 'error';
    user: User;
    count?: number;
  }
  const props = withDefaults(defineProps<Props>(), {
    count: 0
  });
  
  // ✅ Best - With runtime validation
  const props = defineProps({
    status: {
      type: String as PropType<'syncing' | 'synced' | 'error'>,
      required: true,
      validator: (value: string) => ['syncing', 'synced', 'error'].includes(value)
    }
  });
  ```

### Template Directive Best Practices
- **MUST always use `:key` with `v-for` directives**
- **MUST NOT use `v-if` and `v-for` on the same element**
- **Rationale**: Keys maintain component state and enable predictable DOM updates; separate directives prevent evaluation errors and improve performance
- **Examples**:
  ```vue
  <!-- ❌ Bad - Missing key, combined directives -->
  <li v-for="user in users" v-if="user.isActive">
    {{ user.name }}
  </li>
  
  <!-- ✅ Good - Proper key and separated logic -->
  <li v-for="user in activeUsers" :key="user.id">
    {{ user.name }}
  </li>
  
  <script setup lang="ts">
  const activeUsers = computed(() => 
    users.value.filter(user => user.isActive)
  );
  </script>
  ```

### Component Styling Architecture
- **MUST use scoped styling or CSS modules for component-specific styles**
- **SHOULD use consistent class naming conventions (BEM recommended)**
- **Rationale**: Prevents style conflicts, enables style encapsulation, and improves maintainability in large applications
- **Examples**:
  ```vue
  <!-- ✅ Scoped styles -->
  <template>
    <button class="button button--primary">Submit</button>
  </template>
  <style scoped lang="scss">
  .button {
    border: none;
    padding: 8px 16px;
    &--primary {
      background-color: var(--color-primary);
      color: white;
    }
  }
  </style>
  
  <!-- ✅ CSS Modules -->
  <template>
    <button :class="[$style.button, $style.primary]">Submit</button>
  </template>
  <style module lang="scss">
  .button { border: none; padding: 8px 16px; }
  .primary { background-color: var(--color-primary); }
  </style>
  
  <!-- ✅ BEM convention -->
  <template>
    <button class="c-Button c-Button--primary">Submit</button>
  </template>
  <style lang="scss">
  .c-Button {
    border: none;
    &--primary { background-color: var(--color-primary); }
  }
  </style>
  ```

### TypeScript Integration Standards
- **MUST use strict TypeScript configuration**
- **MUST define interfaces for all component props, emits, and complex data structures**
- **SHOULD use generic types for reusable components**
- **Examples**:
  ```typescript
  // ✅ Component with TypeScript integration
  interface User {
    id: number;
    name: string;
    role: 'admin' | 'user' | 'guest';
  }
  
  interface Props {
    users: User[];
    loading?: boolean;
  }
  
  interface Emits {
    (e: 'user-selected', user: User): void;
    (e: 'refresh'): void;
  }
  
  const props = withDefaults(defineProps<Props>(), { loading: false });
  const emit = defineEmits<Emits>();
  
  // ✅ Generic reusable component
  interface ListProps<T> {
    items: T[];
    keyField: keyof T;
  }
  ```

### File Organization and Structure
- **MUST place each component in its own file when using a build system**
- **MUST use PascalCase for all component filenames throughout the project**
- **Rationale**: Improves component discoverability, enables better IDE autocompletion, and prevents case-sensitivity issues across different file systems
- **Examples**:
  ```
  // ✅ Good - PascalCase (recommended for TypeScript projects)
  components/
  ├── TodoList.vue
  ├── TodoItem.vue
  └── UserProfile.vue
  
  // ❌ Bad - Mixed casing
  components/
  ├── mycomponent.vue
  ├── MyComponent.vue
  └── my-component.vue
  ```

### Base Component Naming Strategy
- **MUST prefix base/presentational components with consistent prefix** (`Base`, `App`, or `V`)
- **MUST use full descriptive names, avoiding abbreviations**
- **Rationale**: Creates clear component hierarchy, enables global registration patterns, and improves component discoverability in alphabetically sorted lists
- **Examples**:
  ```typescript
  // ✅ Good - Base component naming
  components/
  ├── BaseButton.vue
  ├── BaseInput.vue
  └── BaseCard.vue
  
  // ✅ Good - App-specific prefix
  components/
  ├── AppButton.vue
  ├── AppNavigation.vue
  └── AppFooter.vue
  
  // ❌ Bad - Generic or abbreviated names
  components/
  ├── MyButton.vue          // Unclear ownership
  ├── Btn.vue              // Abbreviated
  └── Icon.vue             // Too generic
  
  // ✅ Good - Full descriptive names
  components/
  ├── StudentDashboardSettings.vue
  └── PaymentMethodSelector.vue
  
  // ❌ Bad - Abbreviations
  components/
  ├── SdSettings.vue
  └── PmtSelector.vue
  ```

### Component Relationship and Coupling
- **MUST use parent component name as prefix for tightly coupled child components**
- **MUST order component names from general to specific (highest-level words first)**
- **Rationale**: Makes component relationships evident, keeps related files together in alphabetical sorting, and improves navigation
- **Examples**:
  ```typescript
  // ✅ Good - Tightly coupled naming
  components/
  ├── TodoList.vue
  ├── TodoListItem.vue
  └── TodoListItemButton.vue
  
  // ✅ Good - General to specific ordering
  components/
  ├── SearchButtonClear.vue
  ├── SearchButtonRun.vue
  ├── SearchInputQuery.vue
  └── SettingsCheckboxTerms.vue
  
  // ❌ Bad - Unclear relationships
  components/
  ├── TodoList.vue
  ├── TodoItem.vue          // Should be TodoListItem
  ├── TodoButton.vue        // Should be TodoListItemButton
  └── ClearButton.vue       // Should be SearchButtonClear
  ```

### Component Registration and Naming in Code
- **MUST use PascalCase for component names in JavaScript/TypeScript**
- **MUST use camelCase for prop declarations**
- **SHOULD use consistent casing throughout templates (either camelCase or kebab-case)**
- **Examples**:
  ```typescript
  // ✅ Good - Component registration
  import TodoList from './TodoList.vue';
  import UserProfile from './UserProfile.vue';
  
  export default defineComponent({
    name: 'TodoApp',
    components: {
      TodoList,
      UserProfile
    }
  });
  
  // ✅ Good - Prop definitions
  interface Props {
    greetingText: string;      // camelCase in TypeScript
    isVisible: boolean;
    userCount: number;
  }
  
  const props = defineProps<Props>();
  
  // ✅ Good - Template usage (choose one style consistently)
  // Option 1: kebab-case (recommended for in-DOM templates)
  <template>
    <welcome-message 
      greeting-text="Hello"
      :is-visible="true"
    />
  </template>
  
  // Option 2: camelCase (acceptable in SFC templates)
  <template>
    <WelcomeMessage 
      greetingText="Hello"
      :isVisible="true"
    />
  </template>
  
  // ❌ Bad - Mixed casing inconsistency
  <template>
    <welcome-message 
      greetingText="Hello"     <!-- Mixed: kebab component, camel prop -->
      :is-visible="true"
    />
  </template>
  ```

### Template Formatting and Readability
- **MUST split multi-attribute elements across multiple lines**
- **MUST use simple expressions in templates, moving complex logic to computed properties**
- **MUST split complex computed properties into simpler, focused ones**
- **MUST quote all non-empty HTML attribute values**
- **MUST use directive shorthands consistently (all or none)**
- **Examples**:
  ```vue
  <!-- ✅ Good - Multi-line attributes -->
  <UserCard
    :user="currentUser"
    :allow-editing="canEdit"
    @user-updated="handleUserUpdate"
  />
  
  <!-- ✅ Good - Simple template expressions -->
  <template>
    <div class="user-info">
      <h2>{{ formattedUserName }}</h2>
      <p>{{ userStatusMessage }}</p>
    </div>
  </template>
  
  <script setup lang="ts">
  // ✅ Good - Complex logic in computed properties
  const formattedUserName = computed(() => 
    `${user.value.firstName} ${user.value.lastName}`
  );
  
  const userStatusMessage = computed(() => {
    if (user.value.isOnline) return 'Currently online';
    return user.value.lastSeen ? `Last seen ${formatDate(user.value.lastSeen)}` : 'Status unknown';
  });
  </script>
  
  <!-- ❌ Bad - Complex template expression -->
  <template>
    <h2>
      {{ user.firstName.split(' ').map(word => 
           word[0].toUpperCase() + word.slice(1)).join(' ') }}
    </h2>
  </template>
  ```

*References: [Vue.js Essential Style Guide](https://vuejs.org/style-guide/rules-essential.html#use-multi-word-component-names), [Vue.js Strongly Recommended Style Guide](https://vuejs.org/style-guide/rules-strongly-recommended.html#component-files)*