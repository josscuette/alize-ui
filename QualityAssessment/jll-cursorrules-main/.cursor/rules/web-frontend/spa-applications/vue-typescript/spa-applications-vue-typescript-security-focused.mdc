---
description: Vue Security Focused Integrated Cursor Rules
globs: [*.vue],
alwaysApply: false,
---

# Vue - SPA Applications Integrated Cursor Rules (Security Focused)
# Version: 1.0
# Last Updated: 2025-09-09
# Maintained by: Sergio Martín <sergio.martin@eu.jll.com>
# Includes: Security Focused Rules

## Security Implementation - Template Security

### Template Trust and Content Security
- **MUST NEVER use non-trusted content as component templates**
- **MUST NEVER allow user-provided strings in template compilation**
- **MUST treat all user input as potentially malicious**
- **Rationale**: Non-trusted templates allow arbitrary JavaScript execution, equivalent to code injection attacks that can lead to complete application compromise and server breaches in SSR environments
- **Examples**:
  ```typescript
  // ❌ CRITICAL SECURITY VULNERABILITY - Never do this
  import { createApp } from 'vue';
  
  const userProvidedTemplate = getUserInput(); // Potentially malicious
  
  createApp({
    template: `<div>${userProvidedTemplate}</div>` // NEVER DO THIS
  }).mount('#app');
  
  // ❌ CRITICAL - Dynamic template compilation from user input
  const DynamicComponent = {
    template: userInput // EXTREMELY DANGEROUS
  };
  
  // ✅ SECURE - Only use trusted, developer-controlled templates
  const SafeComponent = defineComponent({
    template: `
      <div class="user-content">
        <h2>{{ sanitizedTitle }}</h2>
        <p>{{ escapedContent }}</p>
      </div>
    `
  });
  
  // ✅ SECURE - Render user content as data, not templates
  <template>
    <div class="user-post">
      <h2>{{ post.title }}</h2> <!-- Auto-escaped by Vue -->
      <div v-html="sanitizedHtml"></div> <!-- Only after sanitization -->
    </div>
  </template>
  ```

### HTML Content Security and XSS Prevention
- **MUST rely on Vue's automatic HTML escaping** for user content
- **MUST sanitize HTML content** before using v-html directive
- **MUST validate the safety of HTML** before rendering with v-html
- **Rationale**: Vue automatically escapes HTML content to prevent XSS attacks, but v-html bypasses this protection and requires manual sanitization
- **Examples**:
  ```vue
  <template>
    <!-- ✅ SECURE - Vue automatically escapes HTML content -->
    <div class="user-comment">
      <h3>{{ userComment.title }}</h3>
      <p>{{ userComment.content }}</p>
      <!-- Even if content contains <script>alert('xss')</script>, it's escaped -->
    </div>
    
    <!-- ❌ DANGEROUS - v-html without sanitization -->
    <div v-html="userProvidedHtml"></div>
    
    <!-- ✅ SECURE - v-html with proper sanitization -->
    <div v-html="sanitizedUserHtml"></div>
  </template>
  
  <script setup lang="ts">
  import DOMPurify from 'dompurify';
  
  interface UserContent {
    title: string;
    content: string;
    rawHtml?: string;
  }
  
  const props = defineProps<{
    userContent: UserContent;
  }>();
  
  // ✅ SECURE - Sanitize HTML before rendering
  const sanitizedUserHtml = computed(() => {
    if (!props.userContent.rawHtml) return '';
    
    // Use DOMPurify or similar library for HTML sanitization
    return DOMPurify.sanitize(props.userContent.rawHtml, {
      ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
      ALLOWED_ATTR: ['class'],
      FORBID_SCRIPT: true,
      FORBID_TAGS: ['script', 'object', 'embed', 'link', 'style']
    });
  });
  
  // ❌ DANGEROUS - Never trust user HTML without sanitization
  const unsafeHtml = computed(() => props.userContent.rawHtml);
  </script>
  ```

## Security Implementation - Attribute and URL Security

### Dynamic Attribute Binding Security
- **MUST validate user-provided attribute values**
- **MUST sanitize URLs** before binding to href attributes
- **MUST restrict dynamic style bindings** to safe properties only
- **Rationale**: Dynamic attributes can be exploited for XSS attacks through JavaScript URLs, event handlers, and CSS injection
- **Examples**:
  ```vue
  <template>
    <!-- ❌ DANGEROUS - Unsanitized URL binding -->
    <a :href="userProvidedUrl">Click me</a>
    
    <!-- ❌ DANGEROUS - Dynamic style object from user -->
    <div :style="userProvidedStyles">Content</div>
    
    <!-- ✅ SECURE - Sanitized URL with validation -->
    <a :href="sanitizedUrl" :target="linkTarget">
      {{ linkText }}
    </a>
    
    <!-- ✅ SECURE - Restricted style properties -->
    <div :style="safeStyles">Content</div>
    
    <!-- ✅ SECURE - Whitelist approach for user styling -->
    <div 
      :style="{
        color: validatedColor,
        backgroundColor: validatedBackground,
        fontSize: validatedFontSize
      }"
    >
      User customizable content
    </div>
  </template>
  
  <script setup lang="ts">
  import { sanitizeUrl } from '@braintree/sanitize-url';
  
  interface UserLink {
    url: string;
    text: string;
    openInNewTab?: boolean;
  }
  
  const props = defineProps<{
    userLink: UserLink;
    userStyles?: Record<string, string>;
  }>();
  
  // ✅ SECURE - URL sanitization to prevent javascript: URLs
  const sanitizedUrl = computed(() => {
    const url = props.userLink.url;
    
    // Sanitize to prevent javascript:, data:, vbscript: etc.
    const sanitized = sanitizeUrl(url);
    
    // Additional validation for allowed protocols
    const allowedProtocols = ['http:', 'https:', 'mailto:', 'tel:'];
    try {
      const urlObj = new URL(sanitized);
      if (!allowedProtocols.includes(urlObj.protocol)) {
        return '#'; // Safe fallback
      }
      return sanitized;
    } catch {
      return '#'; // Invalid URL fallback
    }
  });
  
  const linkTarget = computed(() => 
    props.userLink.openInNewTab ? '_blank' : '_self'
  );
  
  const linkText = computed(() => 
    props.userLink.text.slice(0, 100) // Limit length
  );
  
  // ✅ SECURE - Whitelist approach for safe CSS properties
  const safeStyles = computed(() => {
    if (!props.userStyles) return {};
    
    const allowedProperties = ['color', 'backgroundColor', 'fontSize', 'fontWeight'];
    const safeStyles: Record<string, string> = {};
    
    for (const [key, value] of Object.entries(props.userStyles)) {
      if (allowedProperties.includes(key) && isValidCSSValue(value)) {
        safeStyles[key] = value;
      }
    }
    
    return safeStyles;
  });
  
  // CSS value validation helper
  const isValidCSSValue = (value: string): boolean => {
    // Prevent CSS injection attacks
    const dangerousPatterns = [
      /javascript:/i,
      /expression\(/i,
      /url\(/i,
      /@import/i,
      /behavior:/i
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(value));
  };
  
  // ✅ SECURE - Validated color values
  const validatedColor = computed(() => {
    const color = props.userStyles?.color;
    if (!color) return 'inherit';
    
    // Allow only hex colors, named colors, or rgb/rgba
    const colorRegex = /^(#[0-9a-f]{3,6}|rgb\([0-9,\s]+\)|rgba\([0-9,.\s]+\)|[a-z]+)$/i;
    return colorRegex.test(color) ? color : 'inherit';
  });
  </script>
  ```

## Security Implementation - Event Handler Security

### Event Binding and JavaScript Injection Prevention
- **MUST NEVER bind user-provided JavaScript** to event handlers
- **MUST validate and sanitize event handler data**
- **MUST use Vue's event system** instead of inline JavaScript
- **Rationale**: User-provided JavaScript in event handlers enables direct code execution and XSS attacks
- **Examples**:
  ```vue
  <template>
    <!-- ❌ EXTREMELY DANGEROUS - User-provided event handlers -->
    <button :onclick="userProvidedHandler">Click me</button>
    <div :onmouseover="userScript">Hover me</div>
    
    <!-- ❌ DANGEROUS - Dynamic event binding with user input -->
    <button v-on:[userEventType]="userHandler">Dynamic event</button>
    
    <!-- ✅ SECURE - Controlled event handlers -->
    <button @click="handleSecureClick">Secure Click</button>
    <div @mouseover="handleSecureHover">Secure Hover</div>
    
    <!-- ✅ SECURE - Parameterized event handlers -->
    <button 
      v-for="action in validatedActions" 
      :key="action.id"
      @click="handleAction(action)"
    >
      {{ action.label }}
    </button>
  </template>
  
  <script setup lang="ts">
  interface UserAction {
    id: string;
    type: 'navigate' | 'submit' | 'toggle' | 'delete';
    label: string;
    data?: Record<string, any>;
  }
  
  const props = defineProps<{
    actions: UserAction[];
  }>();
  
  // ✅ SECURE - Validated actions with controlled execution
  const validatedActions = computed(() => {
    const allowedTypes = ['navigate', 'submit', 'toggle', 'delete'];
    
    return props.actions.filter(action => {
      // Validate action structure
      if (!action.id || !action.type || !action.label) return false;
      
      // Whitelist allowed action types
      if (!allowedTypes.includes(action.type)) return false;
      
      // Sanitize label
      action.label = action.label.slice(0, 50).replace(/<[^>]*>/g, '');
      
      return true;
    });
  });
  
  // ✅ SECURE - Controlled action handler
  const handleAction = (action: UserAction) => {
    // Validate action at execution time
    if (!validatedActions.value.find(a => a.id === action.id)) {
      console.warn('Invalid action attempted:', action.id);
      return;
    }
    
    switch (action.type) {
      case 'navigate':
        handleNavigation(action.data?.url);
        break;
      case 'submit':
        handleSubmission(action.data);
        break;
      case 'toggle':
        handleToggle(action.data?.target);
        break;
      case 'delete':
        handleDeletion(action.data?.id);
        break;
      default:
        console.warn('Unknown action type:', action.type);
    }
  };
  
  const handleNavigation = (url?: string) => {
    if (!url) return;
    
    // Validate URL before navigation
    const sanitized = sanitizeUrl(url);
    if (sanitized && sanitized !== 'about:blank') {
      router.push(sanitized);
    }
  };
  
  const handleSecureClick = (event: MouseEvent) => {
    // Controlled click handler with validation
    event.preventDefault();
    
    // Perform secure action
    console.log('Secure click handled');
  };
  
  const handleSecureHover = (event: MouseEvent) => {
    // Controlled hover handler
    const target = event.target as HTMLElement;
    
    // Safe DOM manipulation
    target.classList.add('hovered');
  };
  </script>
  ```

## Security Implementation - Content Security Policy (CSP)

### CSP Configuration and Enforcement
- **MUST implement Content Security Policy** headers
- **MUST use nonce-based CSP** for inline scripts when necessary
- **SHOULD use strict CSP directives** to prevent XSS
- **Rationale**: CSP provides defense-in-depth against XSS attacks by controlling which resources can be loaded and executed
- **Examples**:
  ```typescript
  // ✅ SECURE - CSP configuration for Vue applications
  
  // vite.config.ts or webpack configuration
  export default defineConfig({
    plugins: [
      vue(),
      {
        name: 'csp-headers',
        configureServer(server) {
          server.middlewares.use((req, res, next) => {
            // Generate nonce for each request
            const nonce = crypto.randomBytes(16).toString('base64');
            
            // Set CSP header
            res.setHeader('Content-Security-Policy', [
              "default-src 'self'",
              `script-src 'self' 'nonce-${nonce}' 'strict-dynamic'`,
              "style-src 'self' 'unsafe-inline'", // Vue SFC styles
              "img-src 'self' data: https:",
              "font-src 'self' https:",
              "connect-src 'self' https://api.yourdomain.com",
              "frame-ancestors 'none'",
              "base-uri 'self'",
              "form-action 'self'"
            ].join('; '));
            
            // Store nonce for use in HTML template
            res.locals.nonce = nonce;
            next();
          });
        }
      }
    ]
  });
  
  // ✅ SECURE - CSP-compliant Vue component
  <template>
    <div class="secure-component">
      <!-- All inline styles should be in SFC <style> blocks -->
      <h1 class="title">{{ title }}</h1>
      
      <!-- No inline event handlers -->
      <button @click="handleClick" class="action-button">
        {{ buttonText }}
      </button>
      
      <!-- External resources from allowed origins only -->
      <img 
        :src="validatedImageUrl" 
        :alt="imageAlt"
        class="content-image"
      />
    </div>
  </template>
  
  <script setup lang="ts">
  // ✅ SECURE - No eval() or Function() constructors
  const props = defineProps<{
    title: string;
    buttonText: string;
    imageUrl: string;
    imageAlt: string;
  }>();
  
  // ✅ SECURE - Validate external resource URLs
  const validatedImageUrl = computed(() => {
    const url = props.imageUrl;
    
    try {
      const urlObj = new URL(url);
      
      // Allow only specific trusted domains
      const allowedDomains = [
        'images.yourdomain.com',
        'cdn.yourdomain.com',
        'secure-cdn.example.com'
      ];
      
      if (allowedDomains.includes(urlObj.hostname)) {
        return url;
      }
      
      // Fallback to placeholder
      return '/images/placeholder.jpg';
    } catch {
      return '/images/placeholder.jpg';
    }
  });
  
  const handleClick = () => {
    // ✅ SECURE - No dynamic code execution
    // All logic is statically defined
    console.log('Button clicked securely');
  };
  </script>
  
  <style scoped>
  /* ✅ SECURE - All styles in SFC blocks, no inline styles */
  .secure-component {
    padding: 1rem;
    border: 1px solid #e0e0e0;
  }
  
  .title {
    color: #333;
    font-size: 1.5rem;
  }
  
  .action-button {
    background-color: #007bff;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    cursor: pointer;
  }
  
  .content-image {
    max-width: 100%;
    height: auto;
  }
  </style>
  ```

*Reference: [Vue.js Security Best Practices](https://vuejs.org/guide/best-practices/security.html#security)*
